<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title></title>
<script>

!function(){var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;

(function(){function R(a){function d(e){var b=e.charCodeAt(0);if(b!==92)return b;var a=e.charAt(1);return(b=r[a])?b:"0"<=a&&a<="7"?parseInt(e.substring(1),8):a==="u"||a==="x"?parseInt(e.substring(2),16):e.charCodeAt(1)}function g(e){if(e<32)return(e<16?"\\x0":"\\x")+e.toString(16);e=String.fromCharCode(e);return e==="\\"||e==="-"||e==="]"||e==="^"?"\\"+e:e}function b(e){var b=e.substring(1,e.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),e=[],a=

b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,f=b.length;a<f;++a){var h=b[a];if(/\\[bdsw]/i.test(h))c.push(h);else{var h=d(h),l;a+2<f&&"-"===b[a+1]?(l=d(b[a+2]),a+=2):l=h;e.push([h,l]);l<65||h>122||(l<65||h>90||e.push([Math.max(65,h)|32,Math.min(l,90)|32]),l<97||h>122||e.push([Math.max(97,h)&-33,Math.min(l,122)&-33]))}}e.sort(function(e,a){return e[0]-a[0]||a[1]-e[1]});b=[];f=[];for(a=0;a<e.length;++a)h=e[a],h[0]<=f[1]+1?f[1]=Math.max(f[1],h[1]):b.push(f=h);for(a=0;a<b.length;++a)h=b[a],c.push(g(h[0])),

h[1]>h[0]&&(h[1]+1>h[0]&&c.push("-"),c.push(g(h[1])));c.push("]");return c.join("")}function s(e){for(var a=e.source.match(/\[(?:[^\\\] ]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),c=a.length,d=[],f=0,h=0;f<c;++f){var l=a[f];l==="("?++h:"\\"===l.charAt(0)&&(l=+l.substring(1))&&(l<=h?d[l]=-1:a[f]=g(l))}for(f=1;f<d.length;++f)-1===d[f]&&(d[f]=++x);for(h=f=0;f<c;++f)l=a[f],l==="("?(++h,d[h]||(a[f]="(?:")):"\\"===l.charAt(0)&&(l=+l.substring(1))&&l<=h&&

(a[f]="\\"+d[l]);for(f=0;f<c;++f)"^"===a[f]&&"^"!==a[f+1]&&(a[f]="");if(e.ignoreCase&&m)for(f=0;f<c;++f)l=a[f],e=l.charAt(0),l.length>=2&&e==="["?a[f]=b(l):e!=="\\"&&(a[f]=l.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var x=0,m=!1,j=!1,k=0,c=a.length;k<c;++k){var i=a[k];if(i.ignoreCase)j=!0;else if(/[a-z]/i.test(i.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){m=!0;j=!1;break}}for(var r={b:8,t:9,n:10,v:11,

f:12,r:13},n=[],k=0,c=a.length;k<c;++k){i=a[k];if(i.global||i.multiline)throw Error(""+i);n.push("(?:"+s(i)+")")}return RegExp(n.join("|"),j?"gi":"g")}function S(a,d){function g(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)g(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)s[j]="\n",m[j<<1]=x++,m[j++<<1|1]=a}}else if(c==3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\r\n?/g,"\n"):c.replace(/[\t\n\r ]+/g," "),s[j]=c,m[j<<1]=x,x+=c.length,m[j++<<1|1]=

a)}var b=/(?:^|\s)nocode(?:\s|$)/,s=[],x=0,m=[],j=0;g(a);return{a:s.join("").replace(/\n$/,""),d:m}}function H(a,d,g,b){d&&(a={a:d,e:a},g(a),b.push.apply(b,a.g))}function T(a){for(var d=void 0,g=a.firstChild;g;g=g.nextSibling)var b=g.nodeType,d=b===1?d?a:g:b===3?U.test(g.nodeValue)?a:d:d;return d===a?void 0:d}function D(a,d){function g(a){for(var j=a.e,k=[j,"pln"],c=0,i=a.a.match(s)||[],r={},n=0,e=i.length;n<e;++n){var z=i[n],w=r[z],t=void 0,f;if(typeof w==="string")f=!1;else{var h=b[z.charAt(0)];

if(h)t=z.match(h[1]),w=h[0];else{for(f=0;f<x;++f)if(h=d[f],t=z.match(h[1])){w=h[0];break}t||(w="pln")}if((f=w.length>=5&&"lang-"===w.substring(0,5))&&!(t&&typeof t[1]==="string"))f=!1,w="src";f||(r[z]=w)}h=c;c+=z.length;if(f){f=t[1];var l=z.indexOf(f),B=l+f.length;t[2]&&(B=z.length-t[2].length,l=B-f.length);w=w.substring(5);H(j+h,z.substring(0,l),g,k);H(j+h+l,f,I(w,f),k);H(j+h+B,z.substring(B),g,k)}else k.push(j+h,w)}a.g=k}var b={},s;(function(){for(var g=a.concat(d),j=[],k={},c=0,i=g.length;c<i;++c){var r=

g[c],n=r[3];if(n)for(var e=n.length;--e>=0;)b[n.charAt(e)]=r;r=r[1];n=""+r;k.hasOwnProperty(n)||(j.push(r),k[n]=q)}j.push(/[\S\s]/);s=R(j)})();var x=d.length;return g}function v(a){var d=[],g=[];a.tripleQuotedStrings?d.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?d.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,

q,"'\"`"]):d.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&g.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),g.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h(?:h|pp|\+\+)?|[a-z]\w*)>/,q])):d.push(["com",

/^#[^\n\r]*/,q,"#"]));a.cStyleComments&&(g.push(["com",/^\/\/[^\n\r]*/,q]),g.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));if(b=a.regexLiterals){var s=(b=b>1?"":"\n\r")?".":"[\\S\\s]";g.push(["lang-regex",RegExp("^(?:^^\\.?|[+-]|[!=]=?=?|\\#|%=?|&&?=?|\\(|\\*=?|[+\\-]=|->|\\/=?|::?|<<?=?|>>?>?=?|,|;|\\?|@|\\[|~|{|\\^\\^?=?|\\|\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*("+("/(?=[^/*"+b+"])(?:[^/\\x5B\\x5C"+b+"]|\\x5C"+s+"|\\x5B(?:[^\\x5C\\x5D"+b+"]|\\x5C"+

s+")*(?:\\x5D|$))+/")+")")])}(b=a.types)&&g.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&g.push(["kwd",RegExp("^(?:"+b.replace(/[\s,]+/g,"|")+")\\b"),q]);d.push(["pln",/^\s+/,q," \r\n\t\u00a0"]);b="^.[^\\s\\w.$@'\"`/\\\\]*";a.regexLiterals&&(b+="(?!s*/)");g.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,

q],["pun",RegExp(b),q]);return D(d,g)}function J(a,d,g){function b(a){var c=a.nodeType;if(c==1&&!x.test(a.className))if("br"===a.nodeName)s(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&g){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(j.createTextNode(d),a.nextSibling),s(a),c||a.parentNode.removeChild(a)}}function s(a){function b(a,c){var d=

c?a.cloneNode(!1):a,e=a.parentNode;if(e){var e=b(e,1),g=a.nextSibling;e.appendChild(d);for(var i=g;i;i=g)g=i.nextSibling,e.appendChild(i)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var x=/(?:^|\s)nocode(?:\s|$)/,m=/\r\n?|\n/,j=a.ownerDocument,k=j.createElement("li");a.firstChild;)k.appendChild(a.firstChild);for(var c=[k],i=0;i<c.length;++i)b(c[i]);d===(d|0)&&c[0].setAttribute("value",d);var r=j.createElement("ol");

r.className="linenums";for(var d=Math.max(0,d-1|0)||0,i=0,n=c.length;i<n;++i)k=c[i],k.className="L"+(i+d)%10,k.firstChild||k.appendChild(j.createTextNode("\u00a0")),r.appendChild(k);a.appendChild(r)}function p(a,d){for(var g=d.length;--g>=0;){var b=d[g];F.hasOwnProperty(b)?E.console&&console.warn("cannot override language handler %s",b):F[b]=a}}function I(a,d){if(!a||!F.hasOwnProperty(a))a=/^\s*</.test(d)?"default-markup":"default-code";return F[a]}function K(a){var d=a.h;try{var g=S(a.c,a.i),b=g.a;

a.a=b;a.d=g.d;a.e=0;I(d,b)(a);var s=/\bMSIE\s(\d+)/.exec(navigator.userAgent),s=s&&+s[1]<=8,d=/\n/g,x=a.a,m=x.length,g=0,j=a.d,k=j.length,b=0,c=a.g,i=c.length,r=0;c[i]=m;var n,e;for(e=n=0;e<i;)c[e]!==c[e+2]?(c[n++]=c[e++],c[n++]=c[e++]):e+=2;i=n;for(e=n=0;e<i;){for(var p=c[e],w=c[e+1],t=e+2;t+2<=i&&c[t+1]===w;)t+=2;c[n++]=p;c[n++]=w;e=t}c.length=n;var f=a.c,h;if(f)h=f.style.display,f.style.display="none";try{for(;b<k;){var l=j[b+2]||m,B=c[r+2]||m,t=Math.min(l,B),A=j[b+1],G;if(A.nodeType!==1&&(G=x.substring(g,

t))){s&&(G=G.replace(d,"\r"));A.nodeValue=G;var L=A.ownerDocument,o=L.createElement("span");o.className=c[r+1];var v=A.parentNode;v.replaceChild(o,A);o.appendChild(A);g<l&&(j[b+1]=A=L.createTextNode(x.substring(t,l)),v.insertBefore(A,o.nextSibling))}g=t;g>=l&&(b+=2);g>=B&&(r+=2)}}finally{if(f)f.style.display=h}}catch(u){E.console&&console.log(u&&u.stack||u)}}var E=window,y=["break,continue,do,else,for,if,return,while"],C=[[y,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],

"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],M=[C,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],V=[C,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],

N=[C,"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,internal,into,is,let,lock,null,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],C=[C,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],O=[y,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],

P=[y,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],W=[y,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],y=[y,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)\b/,

U=/\S/,X=v({keywords:[M,N,C,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",O,P,y],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),F={};p(X,["default-code"]);p(D([],[["pln",/^[^<?]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",

/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i] ]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);p(D([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"] ],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],

["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",/^style\s*=\s*([^\s"'>]+)/i] ]),["in.tag"]);p(D([],[["atv",/^[\S\s]+/] ]),["uq.val"]);p(v({keywords:M,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);p(v({keywords:"null,true,false"}),["json"]);p(v({keywords:N,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),

["cs"]);p(v({keywords:V,cStyleComments:!0}),["java"]);p(v({keywords:y,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);p(v({keywords:O,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);p(v({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);p(v({keywords:P,

hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);p(v({keywords:C,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);p(v({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);p(v({keywords:W,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);

p(D([],[["str",/^[\S\s]+/] ]),["regex"]);var Y=E.PR={createSimpleLexer:D,registerLangHandler:p,sourceDecorator:v,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:E.prettyPrintOne=function(a,d,g){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;g&&J(b,g,!0);K({h:d,j:g,c:b,i:1});

return b.innerHTML},prettyPrint:E.prettyPrint=function(a,d){function g(){for(var b=E.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;i<p.length&&c.now()<b;i++){for(var d=p[i],j=h,k=d;k=k.previousSibling;){var m=k.nodeType,o=(m===7||m===8)&&k.nodeValue;if(o?!/^\??prettify\b/.test(o):m!==3||/\S/.test(k.nodeValue))break;if(o){j={};o.replace(/\b(\w+)=([\w%+\-.:]+)/g,function(a,b,c){j[b]=c});break}}k=d.className;if((j!==h||e.test(k))&&!v.test(k)){m=!1;for(o=d.parentNode;o;o=o.parentNode)if(f.test(o.tagName)&&

o.className&&e.test(o.className)){m=!0;break}if(!m){d.className+=" prettyprinted";m=j.lang;if(!m){var m=k.match(n),y;if(!m&&(y=T(d))&&t.test(y.tagName))m=y.className.match(n);m&&(m=m[1])}if(w.test(d.tagName))o=1;else var o=d.currentStyle,u=s.defaultView,o=(o=o?o.whiteSpace:u&&u.getComputedStyle?u.getComputedStyle(d,q).getPropertyValue("white-space"):0)&&"pre"===o.substring(0,3);u=j.linenums;if(!(u=u==="true"||+u))u=(u=k.match(/\blinenums\b(?::(\d+))?/))?u[1]&&u[1].length?+u[1]:!0:!1;u&&J(d,u,o);r=

{h:m,c:d,j:u,i:o};K(r)}}}i<p.length?setTimeout(g,250):"function"===typeof a&&a()}for(var b=d||document.body,s=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],p=[],m=0;m<b.length;++m)for(var j=0,k=b[m].length;j<k;++j)p.push(b[m][j]);var b=q,c=Date;c.now||(c={now:function(){return+new Date}});var i=0,r,n=/\blang(?:uage)?-([\w.]+)(?!\S)/,e=/\bprettyprint\b/,v=/\bprettyprinted\b/,w=/pre|xmp/i,t=/^code$/i,f=/^(?:pre|code|xmp)$/i,

h={};g()}};typeof define==="function"&&define.amd&&define("google-code-prettify",[],function(){return Y})})();}()

</script>
<style>

.pln{color:#1b181b}.str{color:#918b3b}.kwd{color:#7b59c0}.com{color:#9e8f9e}.typ{color:#516aec}.lit{color:#a65926}.clo,.opn,.pun{color:#1b181b}.tag{color:#ca402b}.atn{color:#a65926}.atv{color:#159393}.dec{color:#a65926}.var{color:#ca402b}.fun{color:#516aec}pre.prettyprint{background:#f7f3f7;color:#ab9bab;font-family:Menlo,Consolas,"Bitstream Vera Sans Mono","DejaVu Sans Mono",Monaco,monospace;font-size:12px;line-height:1.5;border:1px solid #d8cad8;padding:10px}ol.linenums{margin-top:0;margin-bottom:0}


body{min-width:200px;max-width:850px;margin:0 auto;padding:30px;}.chapter-nav{font-size: 10pt;}a:link,a:visited{color:#00f}.codeblock_name,code,pre.prettyprint{font-family:Monaco,"Lucida Console",monospace}body{font-size:14pt}.codeblock_name,.math,.seealso,code{font-size:10pt}.codeblock{page-break-inside:avoid;padding-bottom:15px}.math{text-indent:0}pre.prettyprint{font-size:10pt;padding:10px;border-radius:10px;border:none;white-space:pre-wrap}.codeblock_name{margin-top:1.25em;display:block}a:link{text-decoration:none}a:link:not(.lit):hover{color:#00f;text-decoration:underline}a:link:active{color:red}h4{padding-right:1.25em}h4.noheading{margin-bottom:0}h1{text-align:center}code{padding:2px}pre{-moz-tab-size:4;-o-tab-size:4;tab-size:4}p:not(.notp){margin:0;text-indent:2em}.two-col{list-style-type:none}.two-col li:before{content:'-';padding:5px;margin-right:5px;color:orange;background-color:#fff;display:inline-block}@media print{body{font-size:10pt}pre.prettyprint{font-size:8pt}.seealso{font-size:9pt}.codeblock_name,.math,code{font-size:8pt}.math{text-indent:0}}

</style>
</head>
<body onload="prettyPrint()">
<section>
<h1></h1>
<a name="1:1"><div class="section"><h4>1. Introduction</h4></a>
<p>Although one can use the raw C API, the C++ SDK is the easiest way to create an Open Mesh Effect plugin. We'll see in this tutorial how to write a simple plugins with a few effects bundled in it that you may then load as a modifier in <a href="https://github.com/eliemichel/OpenMfxForBlender">the OpenMfx branch of Blender</a>.
</p>
<p><strong>NB</strong> This tutorial follows the principle of <em>literate programming</em>, which means that it is written primarily for human reading, but is also a complete and valid code base if one follows the <code>{Curly bracket titles}</code> to browse through code blocks. The code generated from this text is available <a href="https://github.com/eliemichel/OpenMfx/tree/master/doc/literate/build/TutorialCppSdk">in the git repository</a>.
</p>
<p><img src="../_static/TutorialCppSdk/modifier.png" alt="Our plugin once loaded in Blender. It contains a &#39;Translate&#39; and an &#39;Array&#39; effects.">
</p>

</div>
<a name="1:2"><div class="section"><h4>2. Setup</h4></a>
<p>Setting the project up is pretty straightforward. We create a directory, download the SDK, and use a simple CMake file to build it.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:1">{<strong>setup.sh</strong> <a href="TutorialCppSdk.html#codeblock-1:1">1</a>}</span>
<pre class="prettyprint">
<span class="nocode pln">{Create project, <a href="TutorialCppSdk.html#codeblock-1:2">2</a>}</span>
<span class="nocode pln">{Get OpenMfx SDK, <a href="TutorialCppSdk.html#codeblock-1:3">3</a>}</span>
<span class="nocode pln">{Build plugin, <a href="TutorialCppSdk.html#codeblock-1:5">5</a>}</span>
</pre>



</div>
<p>Create the root directory for your project. It usually starts with "Mfx":
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:2">{Create project <a href="TutorialCppSdk.html#codeblock-1:2">2</a>}</span>
<pre class="prettyprint">
mkdir MfxTutorial
cd MfxTutorial
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:1">1</a></p>
</div>
<p>Get <a href="https://github.com/eliemichel/OpenMfx">the OpenMfx repository</a>, either as a submodule or by <a href="https://github.com/eliemichel/OpenMfx/archive/master.zip">downloading it as a zip</a>. This contains C++ SDK in the <code>CppPluginSupport</code> subdirectory.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:3">{Get OpenMfx SDK <a href="TutorialCppSdk.html#codeblock-1:3">3</a>}</span>
<pre class="prettyprint">
git init
git submodule add https://github.com/eliemichel/OpenMfx
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:1">1</a></p>
</div>
<p>In this example, we'll use CMake as a build system, so create this minimal <code>CMakeLists.txt</code> file configuring the project:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:4">{<strong>CMakeLists.txt</strong> <a href="TutorialCppSdk.html#codeblock-1:4">4</a>}</span>
<pre class="prettyprint">
cmake_minimum_required(VERSION 3.0...3.18.4)
# Name of the project
project(MfxTutorial)

# Add OpenMfx to define CppPluginSupport, the C++ helper API
add_subdirectory(OpenMfx)

# Define the plugin target, called for instance mfx_tutorial
# You may list additional source files after "plugin.cpp"
add_library(mfx_tutorial SHARED plugin.cpp)

# Set up the target to depend on CppPluginSupport and output a file
# called .ofx (rather than the standard .dll or .so)
target_link_libraries(mfx_tutorial PRIVATE CppPluginSupport)
set_target_properties(mfx_tutorial PROPERTIES SUFFIX ".ofx")
</pre>



</div>
<p>To build the plugin, follow the usual cmake workflow:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:5">{Build plugin <a href="TutorialCppSdk.html#codeblock-1:5">5</a>}</span>
<pre class="prettyprint">
mkdir build
cd build
cmake ..
cmake --build .
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:1">1</a></p>
</div>
<p>This CMakeList tells that the source code for the plugin will be in <code>plugin.cpp</code>, so create such a file.
</p>
<p>At the very least, this file must do two things:
</p>
<p><strong>(i) Define effects.</strong> Effects are defined by subclassing the <code>MfxEffect</code> class provided by the SDK:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:6">{Define TranslateEffect <a href="TutorialCppSdk.html#codeblock-1:6">6</a>}</span>
<pre class="prettyprint">
#include &lt;PluginSupport/MfxEffect&gt;

class TranslateEffect : public MfxEffect {
<span class="nocode pln">	{Behavior of TranslateEffect, <a href="TutorialCppSdk.html#codeblock-1:8">8</a>}</span>
};
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:7">7</a></p>
</div>
<p><strong>(ii) Register effects into the final binary.</strong> This is actually a macro handling the boilerplate required to expose the correct symbols in the final library, but you don't have to bother about the details.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:7">{<strong>plugin.cpp</strong> <a href="TutorialCppSdk.html#codeblock-1:7">7</a>}</span>
<pre class="prettyprint">
#include &lt;PluginSupport/MfxRegister&gt;

<span class="nocode pln">{Define TranslateEffect, <a href="TutorialCppSdk.html#codeblock-1:6">6</a>}</span>
<span class="nocode pln">{Define ArrayEffect, <a href="TutorialCppSdk.html#codeblock-1:23">23</a>}</span>

MfxRegister(
    TranslateEffect,
    ArrayEffect
);
</pre>



</div>
</div>
<a name="1:3"><div class="section"><h4>3. Core components of an effect</h4></a>
<p>An effect class like <code>TranslateEffect</code> will at least override the two main methods <code>Describe</code> and <code>Cook</code>. The former defines the effect inputs, outputs and parameters, while the former implements the core process that computes the outputs.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:8">{Behavior of TranslateEffect <a href="TutorialCppSdk.html#codeblock-1:8">8</a>}</span>
<pre class="prettyprint">
protected:
OfxStatus Describe(OfxMeshEffectHandle descriptor) override {
<span class="nocode pln">	{Describe, <a href="TutorialCppSdk.html#codeblock-1:10">10</a>}</span>
}

OfxStatus Cook(OfxMeshEffectHandle instance) override {
<span class="nocode pln">	{Cook, <a href="TutorialCppSdk.html#codeblock-1:13">13</a>}</span>
}
</pre>
<p class="seealso">Added to in section <a href="TutorialCppSdk.html#codeblock-1:9">9</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:6">6</a></p>
</div>
<p>We may also override the <code>GetName()</code> method to set the name displayed to the end user when selecting the effect. 
</p>

<div class="codeblock">
<span class="codeblock_name" >{Behavior of TranslateEffect <a href="TutorialCppSdk.html#codeblock-1:8">8</a>} +=</span>
<pre class="prettyprint">
public:
const char* GetName() override {
	return "Translate";
}
</pre>
<p class="seealso">Added to in section <a href="TutorialCppSdk.html#codeblock-1:9">9</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:6">6</a></p>
</div>
<h3> 3.1. Describing the effect</h3>
<p>The <code>Describe</code> method is called only once upon loading, and does not depend on the actual content of the input.
</p>
<p>We first define a single input and output, using the standardized <code>kOfxMeshMainInput</code> and <code>kOfxMeshMainOutput</code> names, and we could add extra ones with arbitrary names:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:10">{Describe <a href="TutorialCppSdk.html#codeblock-1:10">10</a>}</span>
<pre class="prettyprint">
AddInput(kOfxMeshMainInput);
AddInput(kOfxMeshMainOutput);
</pre>
<p class="seealso">Added to in sections <a href="TutorialCppSdk.html#codeblock-1:11">11</a> and <a href="TutorialCppSdk.html#codeblock-1:12">12</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:8">8</a></p>
</div>
<p><strong>NB</strong> What the API calls "input" is actually any kind of slot, including both inputs and outputs.
</p>
<p>Then we define a few parameters that will be exposed for the user to tune the behavior of our effect. The type of parameters is inferred from their default value.
</p>

<div class="codeblock">
<span class="codeblock_name" >{Describe <a href="TutorialCppSdk.html#codeblock-1:10">10</a>} +=</span>
<pre class="prettyprint">
// Add a vector3 parameter
AddParam("translation", double3{0.0, 0.0, 0.0})
.Label("Translation") // Name used for display
.Range(double3{-10.0, -10.0, -10.0}, double3{10.0, 10.0, 10.0});

// Add a bool parameter
AddParam("tickme", false)
.Label("Tick me!");
</pre>
<p class="seealso">Added to in sections <a href="TutorialCppSdk.html#codeblock-1:11">11</a> and <a href="TutorialCppSdk.html#codeblock-1:12">12</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:8">8</a></p>
</div>
<p>Finally, we tell that everything went OK. Other values are possible, in case of error. (See the definition of <code>OfxStatus</code> in ofxCore.h.)
</p>

<div class="codeblock">
<span class="codeblock_name" >{Describe <a href="TutorialCppSdk.html#codeblock-1:10">10</a>} +=</span>
<pre class="prettyprint">
return kOfxStatOK;
</pre>
<p class="seealso">Added to in sections <a href="TutorialCppSdk.html#codeblock-1:11">11</a> and <a href="TutorialCppSdk.html#codeblock-1:12">12</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:8">8</a></p>
</div>
<h3> 3.2. Cooking</h3>
<p>Once in the <code>Cook</code> we can have access to the parameter values and input data. We first retrieve these, then allocate the output mesh, and finally fill it. At the very end we also don't forget to release input/output memory.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:13">{Cook <a href="TutorialCppSdk.html#codeblock-1:13">13</a>}</span>
<pre class="prettyprint">
<span class="nocode pln">{Get Inputs, <a href="TutorialCppSdk.html#codeblock-1:14">14</a>}</span>
<span class="nocode pln">{Get Parameters, <a href="TutorialCppSdk.html#codeblock-1:16">16</a>}</span>
<span class="nocode pln">{Estimate output size, <a href="TutorialCppSdk.html#codeblock-1:18">18</a>}</span>
<span class="nocode pln">{Allocate output, <a href="TutorialCppSdk.html#codeblock-1:19">19</a>}</span>
<span class="nocode pln">{Fill in output, <a href="TutorialCppSdk.html#codeblock-1:21">21</a>}</span>
<span class="nocode pln">{Release data, <a href="TutorialCppSdk.html#codeblock-1:22">22</a>}</span>
return kOfxStatOK;
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:8">8</a></p>
</div>
<h4> 3.2.a. Get Inputs</h4>
<p>Getting the input is as fast as calling <code>GetInput</code> but then we need to think about what information we need from this input.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:14">{Get Inputs <a href="TutorialCppSdk.html#codeblock-1:14">14</a>}</span>
<pre class="prettyprint">
MfxMesh input_mesh = GetInput(kOfxMeshMainInput).GetMesh();
</pre>
<p class="seealso">Added to in section <a href="TutorialCppSdk.html#codeblock-1:15">15</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:13">13</a></p>
</div>
<p>An input contains <em>attributes</em> that are data attached to either points, (face) corners, faces or the mesh itself. Attribute could have any name, but some are standardized. For instance the point attribute <code>kOfxMeshAttribPointPosition</code> contains the position of points.
</p>

<div class="codeblock">
<span class="codeblock_name" >{Get Inputs <a href="TutorialCppSdk.html#codeblock-1:14">14</a>} +=</span>
<pre class="prettyprint">
MfxAttributeProps input_positions;
input_mesh.GetPointAttribute(kOfxMeshAttribPointPosition)
	.FetchProperties(input_positions);
</pre>
<p class="seealso">Added to in section <a href="TutorialCppSdk.html#codeblock-1:15">15</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:13">13</a></p>
</div>
<p><strong>NB</strong> The type <code>MfxAttributeProps</code> contains actual data and one should avoid copying it around, which is why it is not returned but rather provided by reference to <code>FetchProperties()</code>. Other types so far were blind handles occupying little memory.
</p>
<p>In our final example, we'll duplicate and translate the input geometry, but for now let's focus only on the translation, for which the position attribute is all we need.
</p>
<h4> 3.2.b. Get Parameters</h4>
<p>Parameters are identified by the name used to create them. It is required to specify the type again though. From the handle returned by <code>GetParam()</code> one can get the current value of the parameter with <code>GetValue()</code>:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:16">{Get Parameters <a href="TutorialCppSdk.html#codeblock-1:16">16</a>}</span>
<pre class="prettyprint">
MfxParam&lt;double3&gt; translation_param = GetParam&lt;double3&gt;("translation");
double3 translation = translation_param.GetValue();
</pre>

<p class="seealso">Redefined in section <a href="TutorialCppSdk.html#codeblock-1:17">17</a></p>
<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:13">13</a></p>
</div>
<p>Or, in a more compact way:
</p>

<div class="codeblock">
<span class="codeblock_name" >{Get Parameters <a href="TutorialCppSdk.html#codeblock-1:16">16</a>} :=</span>
<pre class="prettyprint">
double3 translation = GetParam&lt;double3&gt;("translation").GetValue();
</pre>

<p class="seealso">Redefined in section <a href="TutorialCppSdk.html#codeblock-1:17">17</a></p>
<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:13">13</a></p>
</div>
<h4> 3.2.c. Allocate Output</h4>
<p>Since in this first part we only translate the mesh, the size of the output is known already -- we copy properties from the input:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:18">{Estimate output size <a href="TutorialCppSdk.html#codeblock-1:18">18</a>}</span>
<pre class="prettyprint">
MfxMeshProps input_mesh_props;
input_mesh.FetchProperties(input_mesh_props);
int output_point_count = input_mesh_props.pointCount;
int output_corner_count = input_mesh_props.cornerCount;
int output_face_count = input_mesh_props.faceCount;

// Extra properties related to memory usage optimization
int output_no_loose_edge = input_mesh_props.noLooseEdge;
int output_constant_face_size = input_mesh_props.constantFaceSize;
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:13">13</a></p>
</div>
<p>We can then allocate memory using the <code>Allocate()</code> method. Note that some objects like <code>MfxAttributes</code> have methods that can be called either only before or only after the memory allocation. Forwarding attributes, for instance, must occur priori to allocation (see bellow).
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:19">{Allocate output <a href="TutorialCppSdk.html#codeblock-1:19">19</a>}</span>
<pre class="prettyprint">
MfxMesh output_mesh = GetInput(kOfxMeshMainOutput).GetMesh();

<span class="nocode pln">{Forward Attributes, <a href="TutorialCppSdk.html#codeblock-1:20">20</a>}</span>

output_mesh.Allocate(
	output_point_count,
	output_corner_count,
	output_face_count,
	output_no_loose_edge,
	output_constant_face_size);
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:13">13</a></p>
</div>
<p><strong>NB</strong> The last two arguments of <code>Allocate</code> are optional, we'll come back on them later on.
</p>
<p>An output mesh needs at least the attributes <code>kOfxMeshAttribPointPosition</code> (on points), <code>kOfxMeshAttribCornerPoint</code> (on corners) and <code>kOfxMeshPropFaceSize</code> (on faces, telling the number of corners per face).
</p>
<p><img src="../_static/TutorialCppSdk/main-attributes.png" alt="A mesh is at least defined by these three attributes. Corners are listed in the same order then faces, their number being given by the face size attribute.">
</p>
<p>Although we'll modify the position of the points, the two others attributes -- defining the connectivity of the mesh -- will remain identical. In such a case, we can <em>forward</em> them to the output, so that the same memory buffer is reused, without any copy:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:20">{Forward Attributes <a href="TutorialCppSdk.html#codeblock-1:20">20</a>}</span>
<pre class="prettyprint">
output_mesh.GetCornerAttribute(kOfxMeshAttribCornerPoint)
	.ForwardFrom(input_mesh.GetCornerAttribute(kOfxMeshAttribCornerPoint));

output_mesh.GetFaceAttribute(kOfxMeshAttribFaceSize)
	.ForwardFrom(input_mesh.GetFaceAttribute(kOfxMeshAttribFaceSize));
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:19">19</a></p>
</div>
<h4> 3.2.d. Computing Output</h4>
<p>Once the output mesh has been allocated, we can get the <code>data</code> field of the <code>MfxAttributeProps</code> of the output points to a valid buffer that we can freely fill in.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:21">{Fill in output <a href="TutorialCppSdk.html#codeblock-1:21">21</a>}</span>
<pre class="prettyprint">
MfxAttributeProps output_positions;
output_mesh.GetPointAttribute(kOfxMeshAttribPointPosition)
	.FetchProperties(output_positions);

// (NB: This can totally benefit from parallelization using e.g. OpenMP)
for (int i = 0 ; i &lt; output_point_count ; ++i) {
	float *in_p = reinterpret_cast&lt;float*&gt;(input_positions.data + i * input_positions.stride);
	float *out_p = reinterpret_cast&lt;float*&gt;(output_positions.data + i * output_positions.stride);
	out_p[0] = in_p[0] + translation[0];
	out_p[1] = in_p[1] + translation[1];
	out_p[2] = in_p[2] + translation[2];
}
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:13">13</a></p>
</div>
<p>And finally we release the meshes. This will internally convert meshes to the host's representation (which for some attributes is the same).
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:22">{Release data <a href="TutorialCppSdk.html#codeblock-1:22">22</a>}</span>
<pre class="prettyprint">
output_mesh.Release();
input_mesh.Release();
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:13">13</a></p>
</div>
<p>This concludes our first effect, which translates the object.
</p>

</div>
<a name="1:4"><div class="section"><h4>4. Array Modifier</h4></a>
<p>We will now see a slightly more complicated example in which we will need to deal with the connectivity information that in the Translation example we could simply forward.
</p>
<h3> 4.1. Setup and describe</h3>
<p>The base skeleton remains similar:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:23">{Define ArrayEffect <a href="TutorialCppSdk.html#codeblock-1:23">23</a>}</span>
<pre class="prettyprint">
class ArrayEffect : public MfxEffect {
public:
	const char* GetName() override {
		return "Array";
	}
protected:
	OfxStatus Describe(OfxMeshEffectHandle descriptor) override {
<span class="nocode pln">		{Describe ArrayEffect Inputs, <a href="TutorialCppSdk.html#codeblock-1:24">24</a>}</span>
<span class="nocode pln">		{Describe ArrayEffect Parameters, <a href="TutorialCppSdk.html#codeblock-1:25">25</a>}</span>
		return kOfxStatOK;
	}

	OfxStatus Cook(OfxMeshEffectHandle instance) override {
<span class="nocode pln">		{Cook ArrayEffect, <a href="TutorialCppSdk.html#codeblock-1:26">26</a>}</span>
	}
};
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:7">7</a></p>
</div>
<p>Nothing new in the description, we define the standard input/output and some parameters:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:24">{Describe ArrayEffect Inputs <a href="TutorialCppSdk.html#codeblock-1:24">24</a>}</span>
<pre class="prettyprint">
AddInput(kOfxMeshMainInput);
AddInput(kOfxMeshMainOutput);
</pre>

<p class="seealso">Redefined in section <a href="TutorialCppSdk.html#codeblock-1:35">35</a></p>
<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:23">23</a></p>
</div>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:25">{Describe ArrayEffect Parameters <a href="TutorialCppSdk.html#codeblock-1:25">25</a>}</span>
<pre class="prettyprint">
// Number of copies
AddParam("count", 2)
.Label("Count")
.Range(0, 2147483647);

// Translation added at each copy
AddParam("translation", double3{0.0, 0.0, 0.0})
.Label("Translation")
.Range(double3{-10.0, -10.0, -10.0}, double3{10.0, 10.0, 10.0});
</pre>
<p class="seealso">Added to in section <a href="TutorialCppSdk.html#codeblock-1:34">34</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:23">23</a></p>
</div>
<h3> 4.2. Cooking output with varying connectivity</h3>
<p>The major change compared with the previous effect lies in the part that fills it in.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:26">{Cook ArrayEffect <a href="TutorialCppSdk.html#codeblock-1:26">26</a>}</span>
<pre class="prettyprint">
<span class="nocode pln">{Get Array inputs and parameters, <a href="TutorialCppSdk.html#codeblock-1:27">27</a>}</span>
<span class="nocode pln">{Allocate Array output, <a href="TutorialCppSdk.html#codeblock-1:28">28</a>}</span>
<span class="nocode pln">{Fill in Array output, <a href="TutorialCppSdk.html#codeblock-1:29">29</a>}</span>

output_mesh.Release();
input_mesh.Release();
return kOfxStatOK;
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:23">23</a></p>
</div>
<p>Getting input and parameter is pretty straightforward:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:27">{Get Array inputs and parameters <a href="TutorialCppSdk.html#codeblock-1:27">27</a>}</span>
<pre class="prettyprint">
MfxMesh input_mesh = GetInput(kOfxMeshMainInput).GetMesh();
MfxMeshProps input_props;
input_mesh.FetchProperties(input_props);

int count = GetParam&lt;int&gt;("count").GetValue();
double3 translation = GetParam&lt;double3&gt;("translation").GetValue();
</pre>
<p class="seealso">Added to in sections <a href="TutorialCppSdk.html#codeblock-1:36">36</a> and <a href="TutorialCppSdk.html#codeblock-1:37">37</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:26">26</a></p>
</div>
<p>Allocating memory just requires to multiply everything by the <code>count</code>. We don't forward anything this time.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:28">{Allocate Array output <a href="TutorialCppSdk.html#codeblock-1:28">28</a>}</span>
<pre class="prettyprint">
MfxMesh output_mesh = GetInput(kOfxMeshMainOutput).GetMesh();

<span class="nocode pln">{Add extra output attributes, <a href="TutorialCppSdk.html#codeblock-1:38">38</a>}</span>

output_mesh.Allocate(
	input_props.pointCount * count,
	input_props.cornerCount * count,
	input_props.faceCount * count,
	input_props.noLooseEdge,
	input_props.constantFaceSize);
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:26">26</a></p>
</div>
<p>This time we need to fill not only the output positions but also the connectivity information. The latter is provided by first the <code>kOfxMeshAttribFaceSize</code> that gives for each face its number of corners, or <em>vertices</em>. The vertices are organized sequentially: corner 1 of face 1, corner 2 of face 1, ..., corner 1 of face 2, etc. Each corner corresponds to a point given by <code>kOfxMeshAttribCornerPoint</code>. So we get these attributes both from the input and from the output:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:29">{Fill in Array output <a href="TutorialCppSdk.html#codeblock-1:29">29</a>}</span>
<pre class="prettyprint">
MfxAttributeProps input_positions, input_corner_points, input_face_size;
input_mesh.GetPointAttribute(kOfxMeshAttribPointPosition).FetchProperties(input_positions);
input_mesh.GetCornerAttribute(kOfxMeshAttribCornerPoint).FetchProperties(input_corner_points);
input_mesh.GetFaceAttribute(kOfxMeshAttribFaceSize).FetchProperties(input_face_size);

MfxAttributeProps output_positions, output_corner_points, output_face_size;
output_mesh.GetPointAttribute(kOfxMeshAttribPointPosition).FetchProperties(output_positions);
output_mesh.GetCornerAttribute(kOfxMeshAttribCornerPoint).FetchProperties(output_corner_points);
output_mesh.GetFaceAttribute(kOfxMeshAttribFaceSize).FetchProperties(output_face_size);
</pre>
<p class="seealso">Added to in sections <a href="TutorialCppSdk.html#codeblock-1:30">30</a> and <a href="TutorialCppSdk.html#codeblock-1:39">39</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:26">26</a></p>
</div>
<p>Important note: when all faces have the same number of vertices (typically they are all triangles or quads), the host may set the <code>constantFaceSize</code> property to a non negative value. In such a case, the <code>kOfxMeshAttribFaceSize</code> attribute must not be used (in order to save up memory).
</p>

<div class="codeblock">
<span class="codeblock_name" >{Fill in Array output <a href="TutorialCppSdk.html#codeblock-1:29">29</a>} +=</span>
<pre class="prettyprint">
for (int k = 0 ; k &lt; count ; ++k) {
<span class="nocode pln">	{Fill positions for the k-th copy, <a href="TutorialCppSdk.html#codeblock-1:31">31</a>}</span>
<span class="nocode pln">	{Fill vert_points for the k-th copy, <a href="TutorialCppSdk.html#codeblock-1:32">32</a>}</span>
	if (input_props.constantFaceSize &lt; 0) {
<span class="nocode pln">		{Fill face_size for the k-th copy, <a href="TutorialCppSdk.html#codeblock-1:33">33</a>}</span>
	}
}
</pre>
<p class="seealso">Added to in sections <a href="TutorialCppSdk.html#codeblock-1:30">30</a> and <a href="TutorialCppSdk.html#codeblock-1:39">39</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:26">26</a></p>
</div>
<p>Filling the output positions is not so different from the Translation effect, just be careful with the indices:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:31">{Fill positions for the k-th copy <a href="TutorialCppSdk.html#codeblock-1:31">31</a>}</span>
<pre class="prettyprint">
for (int i = 0 ; i &lt; input_props.pointCount ; ++i) {
	int j = i + k * input_props.pointCount;
	float *in_p = reinterpret_cast&lt;float*&gt;(input_positions.data + i * input_positions.stride);
	float *out_p = reinterpret_cast&lt;float*&gt;(output_positions.data + j * output_positions.stride);
	out_p[0] = in_p[0] + translation[0] * k;
	out_p[1] = in_p[1] + translation[1] * k;
	out_p[2] = in_p[2] + translation[2] * k;
}
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:30">30</a></p>
</div>
<p>Each k-th copy of the corner references the copy k-th copy of the points, so adds an offset <code>k * input_props.pointCount</code> to the value
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:32">{Fill vert_points for the k-th copy <a href="TutorialCppSdk.html#codeblock-1:32">32</a>}</span>
<pre class="prettyprint">
for (int i = 0 ; i &lt; input_props.cornerCount ; ++i) {
	int j = i + k * input_props.cornerCount;
	int *in_p = reinterpret_cast&lt;int*&gt;(input_corner_points.data + i * input_corner_points.stride);
	int *out_p = reinterpret_cast&lt;int*&gt;(output_corner_points.data + j * output_corner_points.stride);
	out_p[0] = in_p[0] + k * input_props.pointCount;
}
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:30">30</a></p>
</div>
<p>Face sizes are just a simple repetition original values. If these values are contiguous in memory (i.e. the stride is <code>sizeof(int)</code>) this can be speed up using <code>memcpy</code>.
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:33">{Fill face_size for the k-th copy <a href="TutorialCppSdk.html#codeblock-1:33">33</a>}</span>
<pre class="prettyprint">
for (int i = 0 ; i &lt; input_props.faceCount ; ++i) {
	int j = i + k * input_props.faceCount;
	int *in_p = reinterpret_cast&lt;int*&gt;(input_face_size.data + i * input_face_size.stride);
	int *out_p = reinterpret_cast&lt;int*&gt;(output_face_size.data + j * output_face_size.stride);
	out_p[0] = in_p[0];
}
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:30">30</a></p>
</div>
</div>
<a name="1:5"><div class="section"><h4>5. Manipulating UVs</h4></a>
<p>We'll now add a feature to our Array effect: offsetting UVs of the instances so that they don't overlap. Let's first add an option to turn this on or off:
</p>

<div class="codeblock">
<span class="codeblock_name" >{Describe ArrayEffect Parameters <a href="TutorialCppSdk.html#codeblock-1:25">25</a>} +=</span>
<pre class="prettyprint">
AddParam("offset_uv", false)
.Label("Offset UVs");
</pre>
<p class="seealso">Added to in section <a href="TutorialCppSdk.html#codeblock-1:34">34</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:23">23</a></p>
</div>
<p>Then we will also need to tell the host that we will manipulate UV-related attributes. The attributes we've been using so far were the three mandatory attributes, so we did not have to, but for other attributes, one must call <code>RequestAttribute()</code>.
</p>

<div class="codeblock">
<span class="codeblock_name" >{Describe ArrayEffect Inputs <a href="TutorialCppSdk.html#codeblock-1:24">24</a>} :=</span>
<pre class="prettyprint">
AddInput(kOfxMeshMainInput)
.RequestCornerAttribute(
	"uv0",
	2, MfxAttributeType::Float,
	MfxAttributeSemantic::TextureCoordinate,
	false /* not mandatory */
);

AddInput(kOfxMeshMainOutput);
</pre>

<p class="seealso">Redefined in section <a href="TutorialCppSdk.html#codeblock-1:35">35</a></p>
<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:23">23</a></p>
</div>
<p>The semantic <code>MfxAttributeSemantic::TextureCoordinate</code> may allow the host to display a context sensitive attribute picker to the user. Here we mean that the attribute should ideally (not <em>must</em> because we did not ask it to be mandatory) be a float2, represent texture coordinates, and that we'll refer to it as "uv0" during the cooking step.
</p>
<p>We may now retrieve this attribute at cook time. Since this attribute was not declared mandatory, we must check whether it is available with <code>HasAttribute()</code>.
</p>

<div class="codeblock">
<span class="codeblock_name" >{Get Array inputs and parameters <a href="TutorialCppSdk.html#codeblock-1:27">27</a>} +=</span>
<pre class="prettyprint">
bool offset_uv = GetParam&lt;bool&gt;("offset_uv").GetValue();
</pre>
<p class="seealso">Added to in sections <a href="TutorialCppSdk.html#codeblock-1:36">36</a> and <a href="TutorialCppSdk.html#codeblock-1:37">37</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:26">26</a></p>
</div>

<div class="codeblock">
<span class="codeblock_name" >{Get Array inputs and parameters <a href="TutorialCppSdk.html#codeblock-1:27">27</a>} +=</span>
<pre class="prettyprint">
MfxAttributeProps input_uv;
if (offset_uv &amp;&amp; input_mesh.HasCornerAttribute("uv0")) {
	input_mesh.GetCornerAttribute("uv0").FetchProperties(input_uv);
	if (input_uv.componentCount &lt; 2 || input_uv.type != MfxAttributeType::Float) {
		offset_uv = false; // incompatible type, so we deactivate this feature
	}
} else {
	offset_uv = false; // no uv available, so here again we deactivate this feature
}
</pre>
<p class="seealso">Added to in sections <a href="TutorialCppSdk.html#codeblock-1:36">36</a> and <a href="TutorialCppSdk.html#codeblock-1:37">37</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:26">26</a></p>
</div>
<p>We must also add this UV attribute to the output. This must be done <em>before</em> memory allocation (so that there is memory allocated for this attribute).
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:38">{Add extra output attributes <a href="TutorialCppSdk.html#codeblock-1:38">38</a>}</span>
<pre class="prettyprint">
if (offset_uv) {
	output_mesh.AddCornerAttribute(
		"uv0",
		2, MfxAttributeType::Float,
		MfxAttributeSemantic::TextureCoordinate
	);
}
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:28">28</a></p>
</div>
<p>Here again, a semantic hint is added to mean that this attribute should be interpreted by the host as a texture coordinate.
</p>
<p><strong>NB</strong> While input attributes are requested in the <code>Describe</code> method, output attributes are created at cook time. This allows the effect to dynamically chose to add attributes or not.
</p>
<p>Once allocated, we can now manipulate UV data:
</p>

<div class="codeblock">
<span class="codeblock_name" >{Fill in Array output <a href="TutorialCppSdk.html#codeblock-1:29">29</a>} +=</span>
<pre class="prettyprint">
if (offset_uv) {
	MfxAttributeProps output_uv;
	output_mesh.GetCornerAttribute("uv0").FetchProperties(output_uv);

	for (int k = 0 ; k &lt; count ; ++k) {
<span class="nocode pln">		{Offset UVs of k-th instance, <a href="TutorialCppSdk.html#codeblock-1:40">40</a>}</span>
	}
}
</pre>
<p class="seealso">Added to in sections <a href="TutorialCppSdk.html#codeblock-1:30">30</a> and <a href="TutorialCppSdk.html#codeblock-1:39">39</a></p>

<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:26">26</a></p>
</div>
<p>We simply move UVs of other instance along the U axis:
</p>

<div class="codeblock">
<span class="codeblock_name" id="codeblock-1:40">{Offset UVs of k-th instance <a href="TutorialCppSdk.html#codeblock-1:40">40</a>}</span>
<pre class="prettyprint">
for (int i = 0 ; i &lt; input_props.cornerCount ; ++i) {
	int j = i + k * input_props.cornerCount;
	float *in_p = reinterpret_cast&lt;float*&gt;(input_uv.data + i * input_uv.stride);
	float *out_p = reinterpret_cast&lt;float*&gt;(output_uv.data + j * output_uv.stride);
	out_p[0] = in_p[0] + k;
	out_p[1] = in_p[1];
}
</pre>


<p class="seealso">Used in section <a href="TutorialCppSdk.html#codeblock-1:39">39</a></p>
</div>
<p><img src="../_static/TutorialCppSdk/final.png" alt="The final plugin used in Blender">
</p>

</div>
<a name="1:6"><div class="section"><h4>6. Conclusion</h4></a>
<p>You are thus able to write Open Mesh Effect plugins for any compatible host using C++. If you encounter any issue during the process feel free to report it on GitHub: <a href="https://github.com/eliemichel/OpenMfx/issues">github.com/eliemichel/OpenMfx/issues</a>.
</p>

</div>
</body>
